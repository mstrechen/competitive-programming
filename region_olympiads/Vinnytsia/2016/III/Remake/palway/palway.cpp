/* GCC */

#define maxN 100 // Ќайб≥льше можливе значенн€ n
#define mod 101 // „исло, за модулем €кого необх≥дно обчислити в≥дпов≥дь

#include <stdio.h>

int n, a[maxN][maxN]; // ¬х≥дн≥ дан≥
int cnt[maxN][maxN][maxN]; // cnt[d][cl][cr] м≥ститиме в≥дпов≥дь дл€ пари ком≥рок (cl, cr)
    // з л≥воњ та правоњ д≥агоналей d (нумерац≥€ д≥агоналей ≥ ком≥рок у програм≥ Ч з нул€)

// getValue обчислюЇ (€кщо цього ще не зроблено) та повертаЇ значенн€ ком≥рки cnt[d][cl][cr]
int getValue(int d, int cl, int cr)
{
    if (cl < 0 || cl > d || cr < 0 || cr > d) // якщо виходимо за меж≥ таблиц≥, повертаЇмо 0
        return 0;
    int v = cnt[d][cl][cr];
    if (v == -1) // якщо значенн€ ком≥рки ще не обчислено, обчислюЇмо його зараз
    {
        if (a[cl][d - cl] == a[n - 1 - d + cr][n - 1 - cr]) // якщо числа в ком≥рках однаков≥
        {
            if (d == 0) // якщо це початкова д≥агональ, то в≥дпов≥дь Ч одиниц€
                v = 1;
            else // ≤накше обчислюЇмо значенн€ рекурентним сп≥вв≥дношенн€м (≥ за модулем 101)
                v = (getValue(d - 1, cl, cr)
                    + getValue(d - 1, cl - 1, cr)
                    + getValue(d - 1, cl, cr - 1)
                    + getValue(d - 1, cl - 1, cr - 1)) % mod;
        }
        else // якщо числа в ком≥рках р≥зн≥, в≥дпов≥дь дл€ ц≥Їњ пари ком≥рок Ч нуль
            v = 0;
        cnt[d][cl][cr] = v;
    }
    return v;
}

int main()
{
//    freopen("table.in", "r", stdin);
//    freopen("table.out", "w", stdout);

    // «читуванн€ даних
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            scanf("%d", &a[i][j]);

    // ≤н≥ц≥ал≥зац≥€ значенн€ми -1 (Ђще не обчисленої) дл€ рекурс≥њ з запамТ€товуванн€м
    for (int d = 0; d < n; d++)
        for (int i = 0; i <= d; i++)
            for (int j = 0; j <= d; j++)
                cnt[d][i][j] = -1;

    // ¬иклик рекурс≥њ з запамТ€товуванн€м та п≥драхунок в≥дпов≥д≥ (оск≥льки доданк≥в не б≥льше
    // н≥ж 100 ≥ кожен не перевищуЇ 100, про переповненн€ на цьому етап≥ можна не турбуватис€)
    int ans = 0;
    for (int i = 0; i < n; i++)
        ans += getValue(n - 1, i, i);

    // ¬иведенн€ в≥дпов≥д≥ за модулем 101
    printf("%d\n", ans % mod);
}
